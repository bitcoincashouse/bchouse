{
  "contractName": "campaignMain",
  "constructorInputs": [
    {
      "name": "platformPkh",
      "type": "bytes20"
    },
    {
      "name": "fundraisingGoal",
      "type": "int"
    },
    {
      "name": "payoutBytecode",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "payout",
      "inputs": []
    },
    {
      "name": "pledge",
      "inputs": [
        {
          "name": "platformPk",
          "type": "pubkey"
        },
        {
          "name": "platformSig",
          "type": "sig"
        }
      ]
    },
    {
      "name": "refund",
      "inputs": []
    }
  ],
  "bytecode": "OP_3 OP_PICK OP_0 OP_NUMEQUAL OP_IF OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY OP_0 OP_OUTPUTVALUE OP_ROT OP_NUMEQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUAL OP_NIP OP_NIP OP_ELSE OP_3 OP_PICK OP_1 OP_NUMEQUAL OP_IF OP_4 OP_PICK OP_HASH160 OP_EQUALVERIFY OP_4 OP_ROLL OP_4 OP_ROLL OP_CHECKSIGVERIFY OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_3 OP_LESSTHANOREQUAL OP_VERIFY OP_0 OP_OUTPUTVALUE OP_OVER d007 OP_ADD OP_LESSTHANOREQUAL OP_VERIFY OP_0 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_0 OP_OUTPUTTOKENCATEGORY OP_OVER OP_2 OP_CAT OP_EQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCOMMITMENT OP_1 OP_SPLIT OP_NIP OP_8 OP_SPLIT OP_SWAP OP_BIN2NUM OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_SUB OP_SWAP OP_OVER OP_NUMEQUALVERIFY OP_DUP OP_0 OP_GREATERTHAN OP_VERIFY OP_1 OP_OUTPUTTOKENCOMMITMENT OP_1 OP_SPLIT OP_DROP OP_1 OP_1 OP_NUM2BIN OP_EQUAL OP_0 OP_UTXOVALUE OP_1 OP_UTXOVALUE OP_ADD OP_4 OP_ROLL d007 OP_ADD OP_LESSTHANOREQUAL OP_BOOLAND OP_IF OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY OP_ENDIF OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUAL OP_IF OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_2 OP_OUTPUTVALUE OP_1 OP_UTXOVALUE OP_2 OP_PICK OP_2 OP_PICK OP_ADD d007 OP_ADD OP_NUMEQUALVERIFY OP_2 OP_OUTPUTBYTECODE OP_3 OP_PICK OP_EQUALVERIFY OP_DROP OP_ELSE OP_1 OP_UTXOVALUE OP_OVER d007 OP_ADD OP_NUMEQUALVERIFY OP_ENDIF OP_2DROP OP_2DROP OP_1 OP_ELSE OP_3 OP_ROLL OP_2 OP_NUMEQUALVERIFY OP_INPUTINDEX OP_0 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY OP_0 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_0 OP_UTXOTOKENCATEGORY OP_OVER OP_2 OP_CAT OP_EQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_0 OP_UTXOVALUE OP_0 OP_OUTPUTVALUE OP_SUB OP_DUP OP_0 OP_GREATERTHAN OP_VERIFY OP_1 OP_UTXOTOKENCOMMITMENT OP_1 OP_SPLIT OP_NIP OP_8 OP_SPLIT OP_SWAP OP_BIN2NUM OP_ROT OP_OVER OP_LESSTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY OP_1 OP_OUTPUTVALUE OP_SWAP d007 OP_SUB OP_GREATERTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUAL OP_NIP OP_NIP OP_NIP OP_ENDIF OP_ENDIF",
  "source": "pragma cashscript ^0.8.0;\n\n// Assurance smart contract which can have unlimited paricipants with option to cancel at any time\n// first input pledger should be p2pkh to allow for cancel at any time in cancelOrRefund.cash\n//  - Platform participation is required for all actions during campaign to reduce polling/unexpected changes.\n//  - Platform is not required post-expiration\n\n// Opcode count: xxx (max xxx)\n// Bytesize: xxx (max xxx)\n\ncontract campaignMain(\n  bytes20 platformPkh,\n  int fundraisingGoal,\n  bytes payoutBytecode, // either 25 bytes for P2PKH output or 23 bytes for P2SH\n) {\n\n  function payout() {\n    // require the contract input to be on index 0 to read its value\n    require(this.activeInputIndex == 0);\n    // require that atleast fundraising goal is reached\n    require(tx.outputs[0].value == fundraisingGoal);\n    // payout can either be to P2PKH or P2SH address\n    require(tx.outputs[0].lockingBytecode == payoutBytecode);\n    // require the campaign is burned\n    require(tx.outputs[0].tokenCategory == 0x);\n  }\n\n  function pledge(pubkey platformPk, sig platformSig) {\n    require(hash160(platformPk) == platformPkh);\n    require(checkSig(platformSig, platformPk));\n\n    // require pledge input to be spent at index 0\n    require(this.activeInputIndex == 0);\n    // require outputs <= 3 so no additional NFTs can be minted\n    require(tx.outputs.length <= 3);\n    // require the campaign does not exceed goal for compatibility with anyonecanpay pledges\n    require(tx.outputs[0].value <= fundraisingGoal + 2000);\n\n    bytes campaignCategoryId = tx.inputs[0].tokenCategory.split(32)[0];\n    // require pledge contract to be spent with correct campaign at index 0\n    require(tx.outputs[0].tokenCategory == campaignCategoryId + 0x02);\n    // require campaign contract bytecode replicated on output index 0\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    // require campaign contract category replicated on output index 0\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    // require campaign fundds increase by an amount\n    // require(tx.outputs[0].value - tx.inputs[0].value >= 10000);\n    \n    // require that it does not mint a *minting* NFTs\n    require(tx.outputs[1].tokenCategory == campaignCategoryId);\n\n    // require the nft committment to contain correct pledge\n    bytes refundCommitment, bytes refundLockingBytecode = tx.outputs[1].nftCommitment.split(1)[1].split(8);\n    int refundCommitmentAmount = int(refundCommitment);\n    int pledgeAmount = tx.outputs[0].value - tx.inputs[0].value;\n    require(refundCommitmentAmount == pledgeAmount);\n    // require campaign to increase in value\n    require(pledgeAmount > 0);\n\n    //if donation, prevent change output unless it overpledges\n    if (tx.outputs[1].nftCommitment.split(1)[0] == bytes1(1) && tx.inputs[0].value + tx.inputs[1].value <= fundraisingGoal + 2000) {\n      require(tx.outputs.length == 2);\n    }\n\n    // if there is a change output\n    if (tx.outputs.length == 3) {\n      // require that it does not mint *any* NFTs\n      require(tx.outputs[2].tokenCategory == 0x);\n      // require no unaccounted funds from pledge input\n      int changeAmount = tx.outputs[2].value;\n      require(tx.inputs[1].value == pledgeAmount + changeAmount + 2000);\n      // require change is returned to refund address\n      require(tx.outputs[2].lockingBytecode == refundLockingBytecode);\n    } else {\n      // require no unaccounted funds from pledge input\n      require(tx.inputs[1].value == pledgeAmount + 2000);\n    }\n  }\n\n  function refund() {\n    // require campaign contract to be spent at index 0\n    require(this.activeInputIndex == 0);\n    // require there to be only 2 outputs so no additional NFTs can be minted\n    require(tx.outputs.length == 2);\n    \n    bytes campaignCategoryId = tx.inputs[0].tokenCategory.split(32)[0];\n    // require campaign contract to be spent with correct campaign at index 0\n    require(tx.inputs[0].tokenCategory == campaignCategoryId + 0x02);\n    // require campaign contract bytecode replicated on output index 0\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    // require campaign contract category replicated on output index 0\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    // require valid refund NFT as input, validate by checking the tokenCategory without capability\n    require(tx.inputs[1].tokenCategory == campaignCategoryId);\n    \n    int refundAmount = tx.inputs[0].value - tx.outputs[0].value;\n    // require campaign to decrease in value\n    require(refundAmount > 0);\n    \n    bytes refundCommitment, bytes refundLockingBytecode = tx.inputs[1].nftCommitment.split(1)[1].split(8);\n    int refundCommitmentAmount = int(refundCommitment);\n    // require campaign balance to decrease by refund amount\n    require(refundAmount <= refundCommitmentAmount);\n    \n    // refund output on index 1 minus tx fee\n    require(tx.outputs[1].lockingBytecode == refundLockingBytecode);\n    require(tx.outputs[1].value >= refundCommitmentAmount - 2000);\n    // require that the refund NFT is burned\n    require(tx.outputs[1].tokenCategory == 0x);\n  }\n}",
  "compiler": {
    "name": "cashc",
    "version": "0.8.2"
  },
  "updatedAt": "2023-12-27T13:46:19.775Z"
}