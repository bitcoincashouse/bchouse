{
  "contractName": "campaignCreate",
  "constructorInputs": [
    {
      "name": "fundraisingGoal",
      "type": "int"
    },
    {
      "name": "pledgerRefundBytecode",
      "type": "bytes"
    },
    {
      "name": "campaignMainBytecode",
      "type": "bytes"
    },
    {
      "name": "campaignExitBytecode",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "forward",
      "inputs": []
    },
    {
      "name": "create",
      "inputs": []
    },
    {
      "name": "pledge",
      "inputs": []
    }
  ],
  "bytecode": "OP_4 OP_PICK OP_0 OP_NUMEQUAL OP_IF OP_INPUTINDEX OP_OUTPOINTINDEX OP_0 OP_NUMNOTEQUAL OP_VERIFY OP_TXOUTPUTCOUNT OP_1 OP_NUMEQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_INPUTINDEX OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE e803 OP_SUB OP_NUMEQUALVERIFY OP_2DROP OP_2DROP OP_DROP OP_1 OP_ELSE OP_4 OP_PICK OP_1 OP_NUMEQUAL OP_IF OP_TXINPUTCOUNT OP_1 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_3 OP_LESSTHANOREQUAL OP_VERIFY OP_0 OP_OUTPUTVALUE OP_DUP OP_ROT d007 OP_ADD OP_LESSTHANOREQUAL OP_VERIFY OP_TXOUTPUTCOUNT OP_3 OP_NUMEQUAL OP_IF OP_2 OP_OUTPUTTOKENCATEGORY OP_0 OP_EQUALVERIFY OP_2 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_2 OP_PICK OP_2 OP_PICK OP_ADD d007 OP_ADD OP_NUMEQUALVERIFY OP_2 OP_OUTPUTBYTECODE OP_3 OP_PICK OP_EQUALVERIFY OP_DROP OP_ELSE OP_0 OP_UTXOVALUE OP_OVER d007 OP_ADD OP_NUMEQUALVERIFY OP_ENDIF OP_INPUTINDEX OP_OUTPOINTTXHASH OP_0 OP_OUTPUTTOKENCATEGORY OP_OVER OP_2 OP_CAT OP_EQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_4 OP_ROLL OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_OUTPUTBYTECODE OP_3 OP_ROLL OP_EQUALVERIFY OP_1 OP_1 OP_NUM2BIN OP_SWAP OP_8 OP_NUM2BIN OP_CAT OP_SWAP OP_CAT OP_1 OP_OUTPUTTOKENCOMMITMENT OP_EQUAL OP_NIP OP_ELSE OP_4 OP_ROLL OP_2 OP_NUMEQUALVERIFY OP_INPUTINDEX OP_1 OP_NUMEQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_3 OP_ROLL OP_EQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_TXOUTPUTCOUNT OP_2 OP_GREATERTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_EQUALVERIFY OP_1 OP_OUTPUTBYTECODE OP_3 OP_ROLL OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCOMMITMENT OP_1 OP_8 OP_ADD OP_SPLIT OP_NIP OP_ROT OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCOMMITMENT OP_1 OP_SPLIT OP_DROP OP_1 OP_1 OP_NUM2BIN OP_EQUALVERIFY OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_GREATERTHAN OP_NIP OP_ENDIF OP_ENDIF",
  "source": "pragma cashscript ^0.8.0;\n\n// Donation forwarding contract for campaign.\n// Allows for campaign creation and pledging. Does not allow cancelling to avoid pulling donations out from a campaign.\n// TODO: have platform forward donations to completed campaign funds to campaigner automatically\n\n// Opcode count: xx (max xxx)\n// Bytesize: xx (max xxx)\n\ncontract campaignCreate(\n  int fundraisingGoal,\n  bytes pledgerRefundBytecode,\n  bytes campaignMainBytecode, \n  bytes campaignExitBytecode\n) {\n  \n  function forward() {\n    //Send this utxo back to this contract if non-zero index\n    require(tx.inputs[this.activeInputIndex].outpointIndex != 0);\n    require(tx.outputs.length == 1);\n    require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);\n    require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value - 1000);\n  }\n\n  function create() {\n    // require this to be only input for campaign contract creation\n    require(tx.inputs.length == 1);\n    // require at least 2 outputs for campaign contract and refund NFT and optional change\n    require(tx.outputs.length <= 3);\n\n    int pledgeAmount = tx.outputs[0].value;\n\n    // require input value to be less than or equal to campaign goal\n    require(pledgeAmount <= fundraisingGoal + 2000);\n\n    // if there is a change output\n    if (tx.outputs.length == 3) {\n      // require that it does not mint *any* NFTs\n      require(tx.outputs[2].tokenCategory == 0x);\n      // require no unaccounted funds from pledge input\n      int changeAmount = tx.outputs[2].value;\n      require(tx.inputs[0].value == pledgeAmount + changeAmount + 2000);\n      // require change is returned to refund address\n      require(tx.outputs[2].lockingBytecode == pledgerRefundBytecode);\n    } else {\n      // require no unaccounted funds from pledge input\n      require(tx.inputs[0].value == pledgeAmount + 2000);\n    }\n\n    // require this input's outpoint to be a valid genesis by requiring input's output to be campaignCategoryId\n    bytes32 campaignCategoryId = tx.inputs[this.activeInputIndex].outpointTransactionHash;\n    // require 1st output to contain minting NFT as well\n    require(tx.outputs[0].tokenCategory == campaignCategoryId + 0x02);\n    // require 1st output to be campaign contract bytecode\n    require(tx.outputs[0].lockingBytecode == campaignMainBytecode);\n    // require 2nd output contains refund NFT (campaignCategoryId without minting 0x02)\n    require(tx.outputs[1].tokenCategory == campaignCategoryId);\n    // require refund NFT to only be spent in certain ways\n    require(tx.outputs[1].lockingBytecode == campaignExitBytecode);\n\n    // require refund NFT to encode initial value minus fee\n    //  No issue if campaign starts with pledge greater than goal, since no further pledges are necessary and no anyonecanpay pledges invalidated\n    bytes pledgeCommitment = bytes1(1) + bytes8(pledgeAmount) + pledgerRefundBytecode;\n    require(tx.outputs[1].nftCommitment == pledgeCommitment);\n  }\n\n  function pledge() {\n    // require pledge input to be spent at index 1\n    require(this.activeInputIndex == 1);\n    // require campaign contract to be spent at index 0\n    require(tx.outputs[0].lockingBytecode == campaignMainBytecode);\n    // require campaign contract bytecode replicated on output index 0\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    // require campaign contract category replicated on output index 0\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    // require at least 2 outputs for refund NFT\n    require(tx.outputs.length >= 2);\n    // require 2nd output contains refund NFT (campaignCategoryId without minting 0x02)\n    require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\n    // require the refund NFT can only be spent in certain ways\n    require(tx.outputs[1].lockingBytecode == campaignExitBytecode);\n    \n    // require the refund NFT commitment to encode refund-address\n    require(tx.outputs[1].nftCommitment.split(1 + 8)[1] == pledgerRefundBytecode);\n    // require the refund NFT commiment to encode donation bit\n    require(tx.outputs[1].nftCommitment.split(1)[0] == bytes1(1));\n    // require campaign increases in value (main pledge code ensures change)\n    require(tx.outputs[0].value > tx.inputs[0].value);\n  }\n}",
  "compiler": {
    "name": "cashc",
    "version": "0.8.2"
  },
  "updatedAt": "2023-12-31T18:21:57.710Z"
}