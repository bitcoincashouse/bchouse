{
  "contractName": "campaignCreate",
  "constructorInputs": [
    {
      "name": "pledgerRefundBytecode",
      "type": "bytes"
    },
    {
      "name": "campaignMainBytecode",
      "type": "bytes"
    },
    {
      "name": "campaignExitBytecode",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "forward",
      "inputs": []
    },
    {
      "name": "create",
      "inputs": []
    },
    {
      "name": "pledge",
      "inputs": []
    },
    {
      "name": "cancel",
      "inputs": []
    }
  ],
  "bytecode": "OP_3 OP_PICK OP_0 OP_NUMEQUAL OP_IF OP_INPUTINDEX OP_OUTPOINTINDEX OP_0 OP_NUMNOTEQUAL OP_VERIFY OP_TXOUTPUTCOUNT OP_1 OP_NUMEQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_INPUTINDEX OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE e803 OP_SUB OP_NUMEQUALVERIFY OP_2DROP OP_2DROP OP_1 OP_ELSE OP_3 OP_PICK OP_1 OP_NUMEQUAL OP_IF OP_TXINPUTCOUNT OP_1 OP_NUMEQUALVERIFY OP_TXOUTPUTCOUNT OP_2 OP_NUMEQUALVERIFY OP_INPUTINDEX OP_OUTPOINTTXHASH OP_0 OP_OUTPUTTOKENCATEGORY OP_OVER OP_2 OP_CAT OP_EQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_3 OP_ROLL OP_EQUALVERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_1 OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY OP_0 OP_UTXOVALUE d007 OP_SUB OP_0 OP_OUTPUTVALUE OP_OVER OP_NUMEQUALVERIFY OP_8 OP_NUM2BIN OP_SWAP OP_CAT OP_1 OP_OUTPUTTOKENCOMMITMENT OP_EQUAL OP_NIP OP_ELSE OP_3 OP_PICK OP_2 OP_NUMEQUAL OP_IF OP_INPUTINDEX OP_1 OP_NUMEQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_TXOUTPUTCOUNT OP_2 OP_GREATERTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_EQUALVERIFY OP_1 OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY OP_1 OP_UTXOVALUE d007 OP_SUB OP_8 OP_NUM2BIN OP_SWAP OP_CAT OP_1 OP_OUTPUTTOKENCOMMITMENT OP_EQUAL OP_NIP OP_ELSE OP_3 OP_ROLL OP_3 OP_NUMEQUALVERIFY OP_INPUTINDEX OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE e803 OP_SUB OP_GREATERTHANOREQUAL OP_VERIFY OP_INPUTINDEX OP_OUTPUTBYTECODE OP_EQUAL OP_NIP OP_NIP OP_ENDIF OP_ENDIF OP_ENDIF",
  "source": "pragma cashscript ^0.8.0;\n\n// Initial forwarding contract for campaign creation\n// Deposit into this contract ensures the appropriate campaign is created\n\n// Opcode count: xx (max xxx)\n// Bytesize: xx (max xxx)\n\ncontract campaignCreate(\n  bytes pledgerRefundBytecode,\n  bytes campaignMainBytecode, \n  bytes campaignExitBytecode\n) {\n  \n  function forward() {\n    //Send this utxo back to this contract if non-zero index\n    require(tx.inputs[this.activeInputIndex].outpointIndex != 0);\n    require(tx.outputs.length == 1);\n    require(tx.outputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);\n    require(tx.outputs[0].value == tx.inputs[this.activeInputIndex].value - 1000);\n  }\n\n  function create() {\n    // require this to be only input for campaign contract creation\n    require(tx.inputs.length == 1);\n    // require at least 2 outputs for campaign contract and refund NFT\n    require(tx.outputs.length == 2);\n\n    // require this input's outpoint to be a valid genesis by requiring input's output to be campaignCategoryId\n    bytes32 campaignCategoryId = tx.inputs[this.activeInputIndex].outpointTransactionHash;\n    // require 1st output to contain minting NFT as well\n    require(tx.outputs[0].tokenCategory == campaignCategoryId + 0x02);\n    // require 1st output to be campaign contract bytecode\n    require(tx.outputs[0].lockingBytecode == campaignMainBytecode);\n    // require 2nd output contains refund NFT (campaignCategoryId without minting 0x02)\n    require(tx.outputs[1].tokenCategory == campaignCategoryId);\n    // require refund NFT to only be spent in certain ways\n    require(tx.outputs[1].lockingBytecode == campaignExitBytecode);\n\n    int initAmount = tx.inputs[0].value - 2000;\n    // require campaign contract to be initialized with inputs value minus fee\n    require(tx.outputs[0].value == initAmount);\n\n    // require refund NFT to encode initial value minus fee\n    bytes pledgeCommitment = bytes8(initAmount) + pledgerRefundBytecode;\n    require(tx.outputs[1].nftCommitment == pledgeCommitment);\n  }\n\n  function pledge() {\n    // require pledge input to be spent at index 1\n    require(this.activeInputIndex == 1);\n    // require campaign contract to be spent at index 0\n    require(tx.outputs[0].lockingBytecode == campaignMainBytecode);\n    // require campaign contract bytecode replicated on output index 0\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    // require campaign contract category replicated on output index 0\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    // require at least 2 outputs for refund NFT\n    require(tx.outputs.length >= 2);\n    // require 2nd output contains refund NFT (campaignCategoryId without minting 0x02)\n    require(tx.outputs[1].tokenCategory == tx.inputs[0].tokenCategory.split(32)[0]);\n    // require the refund NFT can only be spent in certain ways\n    require(tx.outputs[1].lockingBytecode == campaignExitBytecode);\n    \n    // require the refund NFT commitment to be amount + refund-address\n    int value = tx.inputs[1].value - 2000;\n    bytes pledgeCommitment = bytes8(value) + pledgerRefundBytecode;\n    require(tx.outputs[1].nftCommitment == pledgeCommitment);\n  }\n\n  function cancel() {\n    // require output to specified pledger refund with same value minus a small fee\n    require(tx.outputs[this.activeInputIndex].value >= tx.inputs[this.activeInputIndex].value - 1000);\n    require(tx.outputs[this.activeInputIndex].lockingBytecode == pledgerRefundBytecode);\n  }\n}",
  "compiler": {
    "name": "cashc",
    "version": "0.8.2"
  },
  "updatedAt": "2023-12-10T11:29:34.134Z"
}