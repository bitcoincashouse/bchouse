{
  "contractName": "campaignExit",
  "constructorInputs": [
    {
      "name": "platformPkh",
      "type": "bytes20"
    },
    {
      "name": "fundraisingExpires",
      "type": "int"
    }
  ],
  "abi": [
    {
      "name": "refundBeforeExpiration",
      "inputs": [
        {
          "name": "platformPk",
          "type": "pubkey"
        },
        {
          "name": "platformSig",
          "type": "sig"
        }
      ]
    },
    {
      "name": "refundAfterExpiration",
      "inputs": []
    }
  ],
  "bytecode": "OP_2 OP_PICK OP_0 OP_NUMEQUAL OP_IF OP_3 OP_PICK OP_HASH160 OP_EQUALVERIFY OP_2SWAP OP_CHECKSIGVERIFY OP_1 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_0 OP_UTXOTOKENCATEGORY OP_SWAP OP_2 OP_CAT OP_EQUAL OP_NIP OP_NIP OP_ELSE OP_ROT OP_1 OP_NUMEQUALVERIFY OP_SWAP OP_CHECKLOCKTIMEVERIFY OP_DROP OP_1 OP_UTXOTOKENCATEGORY 20 OP_SPLIT OP_DROP OP_0 OP_UTXOTOKENCATEGORY OP_SWAP OP_2 OP_CAT OP_EQUAL OP_NIP OP_ENDIF",
  "source": "pragma cashscript ^0.8.0;\n\n// Pledge receipt of smart contract flipstarter used to cancel or refund pledge\n// All the campaignExit contracts for a given campaign share the same address but with different NFTs attached\n\n// Opcode count: xx (max xxx)\n// Bytesize: xx (max xxx)\n\ncontract campaignExit(bytes20 platformPkh, int fundraisingExpires) {\n  \n  function refundBeforeExpiration(pubkey platformPk, sig platformSig) {\n    // so only the platform can cancel before expiration\n    require(hash160(platformPk) == platformPkh);\n    require(checkSig(platformSig, platformPk));\n\n    // can only be spent with campaign contract (campaign contract ensures the amount and refund address matches)\n    bytes categoryID = tx.inputs[1].tokenCategory.split(32)[0];\n    require(tx.inputs[0].tokenCategory == categoryID + 0x02);\n  }\n\n  function refundAfterExpiration() {\n    // require that the campaign expired\n    require(tx.time >= fundraisingExpires);\n\n    // can only be spent with campaign contract (campaign contract ensures the amount and refund address matches)\n    bytes categoryID = tx.inputs[1].tokenCategory.split(32)[0];\n    require(tx.inputs[0].tokenCategory == categoryID + 0x02);\n  }\n}",
  "compiler": {
    "name": "cashc",
    "version": "0.8.2"
  },
  "updatedAt": "2023-12-10T11:29:34.064Z"
}