{
  "contractName": "campaignEntry",
  "constructorInputs": [
    {
      "name": "pledgerRefundBytecode",
      "type": "bytes"
    },
    {
      "name": "campaignCategoryId",
      "type": "bytes"
    },
    {
      "name": "campaignExitBytecode",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "pledge",
      "inputs": []
    },
    {
      "name": "cancel",
      "inputs": []
    }
  ],
  "bytecode": "OP_3 OP_PICK OP_0 OP_NUMEQUAL OP_IF OP_INPUTINDEX OP_1 OP_NUMEQUALVERIFY OP_0 OP_UTXOTOKENCATEGORY OP_2 OP_PICK OP_2 OP_CAT OP_EQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_0 OP_UTXOBYTECODE OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_0 OP_UTXOTOKENCATEGORY OP_EQUALVERIFY OP_TXOUTPUTCOUNT OP_2 OP_GREATERTHANOREQUAL OP_VERIFY OP_1 OP_OUTPUTTOKENCATEGORY OP_ROT OP_EQUALVERIFY OP_1 OP_OUTPUTBYTECODE OP_ROT OP_EQUALVERIFY OP_1 OP_UTXOVALUE d007 OP_SUB OP_8 OP_NUM2BIN OP_SWAP OP_CAT OP_1 OP_OUTPUTTOKENCOMMITMENT OP_EQUAL OP_NIP OP_ELSE OP_3 OP_ROLL OP_1 OP_NUMEQUALVERIFY OP_INPUTINDEX OP_OUTPUTVALUE OP_INPUTINDEX OP_UTXOVALUE e803 OP_SUB OP_GREATERTHANOREQUAL OP_VERIFY OP_INPUTINDEX OP_OUTPUTBYTECODE OP_EQUAL OP_NIP OP_NIP OP_ENDIF",
  "source": "pragma cashscript ^0.8.0;\n\n// Forward contract to campaign which enables any wallet to pledge\n// Ensures it's only forwarded to specified contract (verifiable on-chain via categoryId reducing bytes) \n// Also ensures a refund NFT is available to pledgers specified refund bytecode\n\n// Opcode count: xx (max xxx)\n// Bytesize: xx (max xxx)\n\ncontract campaignEntry(\n  bytes pledgerRefundBytecode,\n  bytes campaignCategoryId,\n  bytes campaignExitBytecode\n) {\n\n  function pledge() {\n    // require pledge input to be spent at index 1\n    require(this.activeInputIndex == 1);\n    // require pledge contract to be spent with correct campaign at index 0\n    require(tx.inputs[0].tokenCategory == campaignCategoryId + 0x02);\n    // require campaign contract bytecode replicated on output index 0\n    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);\n    // require campaign contract category replicated on output index 0\n    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);\n    // require at least 2 outputs for refund NFT\n    require(tx.outputs.length >= 2);\n    // require 2nd output contains refund NFT (campaignCategoryId without minting 0x02)\n    require(tx.outputs[1].tokenCategory == campaignCategoryId);\n    // require the refund NFT can only be spent in certain ways\n    require(tx.outputs[1].lockingBytecode == campaignExitBytecode);\n    \n    // require the refund NFT commitment to be amount + refund-address\n    int value = tx.inputs[1].value - 2000;\n    bytes pledgeCommitment = bytes8(value) + pledgerRefundBytecode;\n    require(tx.outputs[1].nftCommitment == pledgeCommitment);\n  }\n\n  function cancel() {\n    // require output to be specified pledger refund\n    require(tx.outputs[this.activeInputIndex].value >= tx.inputs[this.activeInputIndex].value - 1000);\n    require(tx.outputs[this.activeInputIndex].lockingBytecode == pledgerRefundBytecode);\n  }\n}",
  "compiler": {
    "name": "cashc",
    "version": "0.8.2"
  },
  "updatedAt": "2023-12-10T11:29:34.089Z"
}