schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# whether this query should be cached (Hasura Cloud only)
directive @cached(
  # measured in seconds
  ttl: Int! = 60

  # refresh the cache entry
  refresh: Boolean! = false
) on QUERY

# Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input SendTransactionRequest {
  encoded_hex: String!
  node_internal_id: bigint!
}

type SendTransactionResult {
  transaction_hash: String!
  transmission_error_message: String
  transmission_success: Boolean!
  validation_error_message: String
  validation_success: Boolean!
}

# Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  # does the column match the given case-insensitive pattern
  _ilike: String
  _in: [String!]

  # does the column match the given POSIX regular expression, case insensitive
  _iregex: String
  _is_null: Boolean

  # does the column match the given pattern
  _like: String
  _lt: String
  _lte: String
  _neq: String

  # does the column NOT match the given case-insensitive pattern
  _nilike: String
  _nin: [String!]

  # does the column NOT match the given POSIX regular expression, case insensitive
  _niregex: String

  # does the column NOT match the given pattern
  _nlike: String

  # does the column NOT match the given POSIX regular expression, case sensitive
  _nregex: String

  # does the column NOT match the given SQL regular expression
  _nsimilar: String

  # does the column match the given POSIX regular expression, case sensitive
  _regex: String

  # does the column match the given SQL regular expression
  _similar: String
}

scalar _text

# A view which maps migration transactions to their index in a particular authchain.
type authchain_migrations_view {
  authbase_internal_id: bigint
  migration_index: bigint
  migration_transaction_internal_id: bigint

  # This function powers the "transaction.authchains[n].migrations[n].transaction" computed field in migration objects. This is a workaround to improve performance over an equivalent "transaction" standard Hasura relationship. When implemented as a relationship, the Hasura-compiled SQL query requires a full scan of the authchain_migrations_view, which is extremely large and expensive to compute.
  transaction(
    # distinct select on columns
    distinct_on: [transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [transaction_order_by!]

    # filter the rows returned
    where: transaction_bool_exp
  ): [transaction!]
}

# order by aggregate values of table "authchain_migrations_view"
input authchain_migrations_view_aggregate_order_by {
  avg: authchain_migrations_view_avg_order_by
  count: order_by
  max: authchain_migrations_view_max_order_by
  min: authchain_migrations_view_min_order_by
  stddev: authchain_migrations_view_stddev_order_by
  stddev_pop: authchain_migrations_view_stddev_pop_order_by
  stddev_samp: authchain_migrations_view_stddev_samp_order_by
  sum: authchain_migrations_view_sum_order_by
  var_pop: authchain_migrations_view_var_pop_order_by
  var_samp: authchain_migrations_view_var_samp_order_by
  variance: authchain_migrations_view_variance_order_by
}

# order by avg() on columns of table "authchain_migrations_view"
input authchain_migrations_view_avg_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# Boolean expression to filter rows from the table "authchain_migrations_view". All fields are combined with a logical 'AND'.
input authchain_migrations_view_bool_exp {
  _and: [authchain_migrations_view_bool_exp!]
  _not: authchain_migrations_view_bool_exp
  _or: [authchain_migrations_view_bool_exp!]
  authbase_internal_id: bigint_comparison_exp
  migration_index: bigint_comparison_exp
  migration_transaction_internal_id: bigint_comparison_exp
  transaction: transaction_bool_exp
}

# order by max() on columns of table "authchain_migrations_view"
input authchain_migrations_view_max_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# order by min() on columns of table "authchain_migrations_view"
input authchain_migrations_view_min_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# Ordering options when selecting data from "authchain_migrations_view".
input authchain_migrations_view_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
  transaction_aggregate: transaction_aggregate_order_by
}

# select columns of table "authchain_migrations_view"
enum authchain_migrations_view_select_column {
  # column name
  authbase_internal_id

  # column name
  migration_index

  # column name
  migration_transaction_internal_id
}

# order by stddev() on columns of table "authchain_migrations_view"
input authchain_migrations_view_stddev_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# order by stddev_pop() on columns of table "authchain_migrations_view"
input authchain_migrations_view_stddev_pop_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# order by stddev_samp() on columns of table "authchain_migrations_view"
input authchain_migrations_view_stddev_samp_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# Streaming cursor of the table "authchain_migrations_view"
input authchain_migrations_view_stream_cursor_input {
  # Stream column input with initial value
  initial_value: authchain_migrations_view_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input authchain_migrations_view_stream_cursor_value_input {
  authbase_internal_id: bigint
  migration_index: bigint
  migration_transaction_internal_id: bigint
}

# order by sum() on columns of table "authchain_migrations_view"
input authchain_migrations_view_sum_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# order by var_pop() on columns of table "authchain_migrations_view"
input authchain_migrations_view_var_pop_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# order by var_samp() on columns of table "authchain_migrations_view"
input authchain_migrations_view_var_samp_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# order by variance() on columns of table "authchain_migrations_view"
input authchain_migrations_view_variance_order_by {
  authbase_internal_id: order_by
  migration_index: order_by
  migration_transaction_internal_id: order_by
}

# A view which contains one row per possible authhead per transaction.
type authchain_view {
  authchain_length: Int

  # An object relationship
  authhead: transaction
  authhead_transaction_hash: bytea

  # An array relationship
  migrations(
    # distinct select on columns
    distinct_on: [authchain_migrations_view_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [authchain_migrations_view_order_by!]

    # filter the rows returned
    where: authchain_migrations_view_bool_exp
  ): [authchain_migrations_view!]!
  transaction_internal_id: bigint
  unspent_authhead: Boolean
}

# order by aggregate values of table "authchain_view"
input authchain_view_aggregate_order_by {
  avg: authchain_view_avg_order_by
  count: order_by
  max: authchain_view_max_order_by
  min: authchain_view_min_order_by
  stddev: authchain_view_stddev_order_by
  stddev_pop: authchain_view_stddev_pop_order_by
  stddev_samp: authchain_view_stddev_samp_order_by
  sum: authchain_view_sum_order_by
  var_pop: authchain_view_var_pop_order_by
  var_samp: authchain_view_var_samp_order_by
  variance: authchain_view_variance_order_by
}

# order by avg() on columns of table "authchain_view"
input authchain_view_avg_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# Boolean expression to filter rows from the table "authchain_view". All fields are combined with a logical 'AND'.
input authchain_view_bool_exp {
  _and: [authchain_view_bool_exp!]
  _not: authchain_view_bool_exp
  _or: [authchain_view_bool_exp!]
  authchain_length: Int_comparison_exp
  authhead: transaction_bool_exp
  authhead_transaction_hash: bytea_comparison_exp
  migrations: authchain_migrations_view_bool_exp
  transaction_internal_id: bigint_comparison_exp
  unspent_authhead: Boolean_comparison_exp
}

# order by max() on columns of table "authchain_view"
input authchain_view_max_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# order by min() on columns of table "authchain_view"
input authchain_view_min_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# Ordering options when selecting data from "authchain_view".
input authchain_view_order_by {
  authchain_length: order_by
  authhead: transaction_order_by
  authhead_transaction_hash: order_by
  migrations_aggregate: authchain_migrations_view_aggregate_order_by
  transaction_internal_id: order_by
  unspent_authhead: order_by
}

# select columns of table "authchain_view"
enum authchain_view_select_column {
  # column name
  authchain_length

  # column name
  authhead_transaction_hash

  # column name
  transaction_internal_id

  # column name
  unspent_authhead
}

# order by stddev() on columns of table "authchain_view"
input authchain_view_stddev_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# order by stddev_pop() on columns of table "authchain_view"
input authchain_view_stddev_pop_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# order by stddev_samp() on columns of table "authchain_view"
input authchain_view_stddev_samp_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# Streaming cursor of the table "authchain_view"
input authchain_view_stream_cursor_input {
  # Stream column input with initial value
  initial_value: authchain_view_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input authchain_view_stream_cursor_value_input {
  authchain_length: Int
  authhead_transaction_hash: bytea
  transaction_internal_id: bigint
  unspent_authhead: Boolean
}

# order by sum() on columns of table "authchain_view"
input authchain_view_sum_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# order by var_pop() on columns of table "authchain_view"
input authchain_view_var_pop_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# order by var_samp() on columns of table "authchain_view"
input authchain_view_var_samp_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

# order by variance() on columns of table "authchain_view"
input authchain_view_variance_order_by {
  authchain_length: order_by
  transaction_internal_id: order_by
}

scalar bigint

# Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

# A blockchain block.
type block {
  # An array relationship
  accepted_by(
    # distinct select on columns
    distinct_on: [node_block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_block_order_by!]

    # filter the rows returned
    where: node_block_bool_exp
  ): [node_block!]!

  # The uint32 packed representation of the difficulty target being used for this block. To be valid, the block hash value must be less than this difficulty target.
  bits: bigint!

  # Encode a full block using the standard P2P network format, returning the result as a hex-encoded string.
  encoded_hex: String

  # The total fee in satoshis paid by all transactions in this block.
  fee_satoshis: bigint

  # The total value in satoshis generated by this block.
  generated_value_satoshis: bigint

  # The 32-byte, double-sha256 hash of the block header (encoded using the standard P2P network format) in big-endian byte order. This is used as a universal, unique identifier for the block. Big-endian byte order is typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  hash: bytea!

  # Encode a block header using the standard P2P network format, returning the result as a hex-encoded string.
  header: String

  # The height of this block: the number of blocks mined between this block and its genesis block (block 0).
  height: bigint!

  # The total number of transaction inputs in this block.
  input_count: bigint

  # The total value in satoshis of all outputs spent by transaction inputs in this block.
  input_value_satoshis: bigint

  # A unique, int64 identifier for this block assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: bigint!

  # The 32-byte root hash of the double-sha256 merkle tree of transactions confirmed by this block. Note, the unusual merkle tree construction used by most chains is vulnerable to CVE-2012-2459. The final node in oddly-numbered levels is duplicated, and special care is required to ensure trees contain minimal duplicatation.
  merkle_root: bytea!

  # The uint32 nonce used for this block. This field allows miners to introduce entropy into the block header, changing the resulting hash during mining.
  nonce: bigint!

  # The total number of transaction outputs in this block.
  output_count: bigint

  # The total value in satoshis of all outputs created by transactions in this block.
  output_value_satoshis: bigint

  # An object relationship
  previous_block: block

  # The 32-byte, double-sha256 hash of the previous block's header in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  previous_block_hash: bytea!

  # The network-encoded size of this block in bytes including transactions.
  size_bytes: bigint!

  # The uint32 current Unix timestamp claimed by the miner at the time this block was mined. By consensus, block timestamps must be within ~2 hours of the actual time, but timestamps are not guaranteed to be accurate. Timestamps of later blocks can also be earlier than their parent blocks.
  timestamp: bigint!

  # The total number of transactions in this block.
  transaction_count: bigint

  # An array relationship
  transactions(
    # distinct select on columns
    distinct_on: [block_transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_transaction_order_by!]

    # filter the rows returned
    where: block_transaction_bool_exp
  ): [block_transaction!]!

  # The "version" field of this block; a 4-byte field typically represented as an int32. While originally designed to indicate a block's version, this field has been used for several other purposes. BIP34 ("Height in Coinbase") enforced a minimum version of 2, BIP66 ("Strict DER Signatures") enforced a minimum version of 3, then BIP9 repurposed most bits of the version field for network signaling. In recent years, the version field is also used for the AsicBoost mining optimization.
  version: bigint!
}

# Boolean expression to filter rows from the table "block". All fields are combined with a logical 'AND'.
input block_bool_exp {
  _and: [block_bool_exp!]
  _not: block_bool_exp
  _or: [block_bool_exp!]
  accepted_by: node_block_bool_exp
  bits: bigint_comparison_exp
  encoded_hex: String_comparison_exp
  fee_satoshis: bigint_comparison_exp
  generated_value_satoshis: bigint_comparison_exp
  hash: bytea_comparison_exp
  header: String_comparison_exp
  height: bigint_comparison_exp
  input_count: bigint_comparison_exp
  input_value_satoshis: bigint_comparison_exp
  internal_id: bigint_comparison_exp
  merkle_root: bytea_comparison_exp
  nonce: bigint_comparison_exp
  output_count: bigint_comparison_exp
  output_value_satoshis: bigint_comparison_exp
  previous_block: block_bool_exp
  previous_block_hash: bytea_comparison_exp
  size_bytes: bigint_comparison_exp
  timestamp: bigint_comparison_exp
  transaction_count: bigint_comparison_exp
  transactions: block_transaction_bool_exp
  version: bigint_comparison_exp
}

# Ordering options when selecting data from "block".
input block_order_by {
  accepted_by_aggregate: node_block_aggregate_order_by
  bits: order_by
  encoded_hex: order_by
  fee_satoshis: order_by
  generated_value_satoshis: order_by
  hash: order_by
  header: order_by
  height: order_by
  input_count: order_by
  input_value_satoshis: order_by
  internal_id: order_by
  merkle_root: order_by
  nonce: order_by
  output_count: order_by
  output_value_satoshis: order_by
  previous_block: block_order_by
  previous_block_hash: order_by
  size_bytes: order_by
  timestamp: order_by
  transaction_count: order_by
  transactions_aggregate: block_transaction_aggregate_order_by
  version: order_by
}

# select columns of table "block"
enum block_select_column {
  # column name
  bits

  # column name
  hash

  # column name
  height

  # column name
  internal_id

  # column name
  merkle_root

  # column name
  nonce

  # column name
  previous_block_hash

  # column name
  size_bytes

  # column name
  timestamp

  # column name
  version
}

# Streaming cursor of the table "block"
input block_stream_cursor_input {
  # Stream column input with initial value
  initial_value: block_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input block_stream_cursor_value_input {
  # The uint32 packed representation of the difficulty target being used for this block. To be valid, the block hash value must be less than this difficulty target.
  bits: bigint

  # The 32-byte, double-sha256 hash of the block header (encoded using the standard P2P network format) in big-endian byte order. This is used as a universal, unique identifier for the block. Big-endian byte order is typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  hash: bytea

  # The height of this block: the number of blocks mined between this block and its genesis block (block 0).
  height: bigint

  # A unique, int64 identifier for this block assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: bigint

  # The 32-byte root hash of the double-sha256 merkle tree of transactions confirmed by this block. Note, the unusual merkle tree construction used by most chains is vulnerable to CVE-2012-2459. The final node in oddly-numbered levels is duplicated, and special care is required to ensure trees contain minimal duplicatation.
  merkle_root: bytea

  # The uint32 nonce used for this block. This field allows miners to introduce entropy into the block header, changing the resulting hash during mining.
  nonce: bigint

  # The 32-byte, double-sha256 hash of the previous block's header in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  previous_block_hash: bytea

  # The network-encoded size of this block in bytes including transactions.
  size_bytes: bigint

  # The uint32 current Unix timestamp claimed by the miner at the time this block was mined. By consensus, block timestamps must be within ~2 hours of the actual time, but timestamps are not guaranteed to be accurate. Timestamps of later blocks can also be earlier than their parent blocks.
  timestamp: bigint

  # The "version" field of this block; a 4-byte field typically represented as an int32. While originally designed to indicate a block's version, this field has been used for several other purposes. BIP34 ("Height in Coinbase") enforced a minimum version of 2, BIP66 ("Strict DER Signatures") enforced a minimum version of 3, then BIP9 repurposed most bits of the version field for network signaling. In recent years, the version field is also used for the AsicBoost mining optimization.
  version: bigint
}

# A many-to-many relationship between blocks and transactions.
type block_transaction {
  # An object relationship
  block: block!

  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: bigint!

  # An object relationship
  transaction: transaction!

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: bigint!

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: bigint!
}

# order by aggregate values of table "block_transaction"
input block_transaction_aggregate_order_by {
  avg: block_transaction_avg_order_by
  count: order_by
  max: block_transaction_max_order_by
  min: block_transaction_min_order_by
  stddev: block_transaction_stddev_order_by
  stddev_pop: block_transaction_stddev_pop_order_by
  stddev_samp: block_transaction_stddev_samp_order_by
  sum: block_transaction_sum_order_by
  var_pop: block_transaction_var_pop_order_by
  var_samp: block_transaction_var_samp_order_by
  variance: block_transaction_variance_order_by
}

# order by avg() on columns of table "block_transaction"
input block_transaction_avg_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# Boolean expression to filter rows from the table "block_transaction". All fields are combined with a logical 'AND'.
input block_transaction_bool_exp {
  _and: [block_transaction_bool_exp!]
  _not: block_transaction_bool_exp
  _or: [block_transaction_bool_exp!]
  block: block_bool_exp
  block_internal_id: bigint_comparison_exp
  transaction: transaction_bool_exp
  transaction_index: bigint_comparison_exp
  transaction_internal_id: bigint_comparison_exp
}

# order by max() on columns of table "block_transaction"
input block_transaction_max_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# order by min() on columns of table "block_transaction"
input block_transaction_min_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# Ordering options when selecting data from "block_transaction".
input block_transaction_order_by {
  block: block_order_by
  block_internal_id: order_by
  transaction: transaction_order_by
  transaction_index: order_by
  transaction_internal_id: order_by
}

# select columns of table "block_transaction"
enum block_transaction_select_column {
  # column name
  block_internal_id

  # column name
  transaction_index

  # column name
  transaction_internal_id
}

# order by stddev() on columns of table "block_transaction"
input block_transaction_stddev_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# order by stddev_pop() on columns of table "block_transaction"
input block_transaction_stddev_pop_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# order by stddev_samp() on columns of table "block_transaction"
input block_transaction_stddev_samp_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# Streaming cursor of the table "block_transaction"
input block_transaction_stream_cursor_input {
  # Stream column input with initial value
  initial_value: block_transaction_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input block_transaction_stream_cursor_value_input {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: bigint

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: bigint

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: bigint
}

# order by sum() on columns of table "block_transaction"
input block_transaction_sum_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# order by var_pop() on columns of table "block_transaction"
input block_transaction_var_pop_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# order by var_samp() on columns of table "block_transaction"
input block_transaction_var_samp_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

# order by variance() on columns of table "block_transaction"
input block_transaction_variance_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
  block_internal_id: order_by

  # The zero-based index of the referenced transaction in the referenced block. (Transaction ordering is critical for reconstructing a block or its merkle tree.)
  transaction_index: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
  transaction_internal_id: order_by
}

scalar bytea

# Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

# ordering argument of a cursor
enum cursor_ordering {
  # ascending ordering of the cursor
  ASC

  # descending ordering of the cursor
  DESC
}

scalar enum_nonfungible_token_capability

# Boolean expression to compare columns of type "enum_nonfungible_token_capability". All fields are combined with logical 'AND'.
input enum_nonfungible_token_capability_comparison_exp {
  _eq: enum_nonfungible_token_capability
  _gt: enum_nonfungible_token_capability
  _gte: enum_nonfungible_token_capability
  _in: [enum_nonfungible_token_capability!]
  _is_null: Boolean
  _lt: enum_nonfungible_token_capability
  _lte: enum_nonfungible_token_capability
  _neq: enum_nonfungible_token_capability
  _nin: [enum_nonfungible_token_capability!]
}

# A transaction input.
type input {
  # The zero-based index of this input in the transaction.
  input_index: bigint!

  # An object relationship
  outpoint: output

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: bigint!

  # An object relationship
  outpoint_transaction: output

  # The 32-byte, double-sha256 hash of the network-encoded transaction from which this input is spent in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  outpoint_transaction_hash: bytea!

  # If the final instruction of the unlocking bytecode is a push instruction, parse its contents as a P2SH redeem bytecode, extracting the first byte of each instruction into a bytecode pattern (excluding length bytes and pushed data). If the last instruction is not a push, return NULL. Note: this function does not confirm that the spent locking bytecode is P2SH. For correct results, only call this function for inputs which spend P2SH outputs.
  redeem_bytecode_pattern: String

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: bigint!

  # An object relationship
  transaction: transaction!

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: bigint!

  # The bytecode used to unlock a transaction output. To spend an output, unlocking bytecode must be included in a transaction input which – when evaluated in the authentication virtual machine with the locking bytecode – completes in valid state.
  unlocking_bytecode: bytea!

  # Extract the first byte of each instruction for the unlocking bytecode of an input. The resulting pattern excludes the contents of pushed values such that similar bytecode sequences produce the same pattern.
  unlocking_bytecode_pattern: String

  # The value in satoshis of all outpoints spent by this transaction. Set to null for coinbase transactions.
  value_satoshis: bigint
}

# order by aggregate values of table "input"
input input_aggregate_order_by {
  avg: input_avg_order_by
  count: order_by
  max: input_max_order_by
  min: input_min_order_by
  stddev: input_stddev_order_by
  stddev_pop: input_stddev_pop_order_by
  stddev_samp: input_stddev_samp_order_by
  sum: input_sum_order_by
  var_pop: input_var_pop_order_by
  var_samp: input_var_samp_order_by
  variance: input_variance_order_by
}

# order by avg() on columns of table "input"
input input_avg_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# Boolean expression to filter rows from the table "input". All fields are combined with a logical 'AND'.
input input_bool_exp {
  _and: [input_bool_exp!]
  _not: input_bool_exp
  _or: [input_bool_exp!]
  input_index: bigint_comparison_exp
  outpoint: output_bool_exp
  outpoint_index: bigint_comparison_exp
  outpoint_transaction: output_bool_exp
  outpoint_transaction_hash: bytea_comparison_exp
  redeem_bytecode_pattern: String_comparison_exp
  sequence_number: bigint_comparison_exp
  transaction: transaction_bool_exp
  transaction_internal_id: bigint_comparison_exp
  unlocking_bytecode: bytea_comparison_exp
  unlocking_bytecode_pattern: String_comparison_exp
  value_satoshis: bigint_comparison_exp
}

# order by max() on columns of table "input"
input input_max_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# order by min() on columns of table "input"
input input_min_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# Ordering options when selecting data from "input".
input input_order_by {
  input_index: order_by
  outpoint: output_order_by
  outpoint_index: order_by
  outpoint_transaction: output_order_by
  outpoint_transaction_hash: order_by
  redeem_bytecode_pattern: order_by
  sequence_number: order_by
  transaction: transaction_order_by
  transaction_internal_id: order_by
  unlocking_bytecode: order_by
  unlocking_bytecode_pattern: order_by
  value_satoshis: order_by
}

# select columns of table "input"
enum input_select_column {
  # column name
  input_index

  # column name
  outpoint_index

  # column name
  outpoint_transaction_hash

  # column name
  sequence_number

  # column name
  transaction_internal_id

  # column name
  unlocking_bytecode
}

# order by stddev() on columns of table "input"
input input_stddev_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# order by stddev_pop() on columns of table "input"
input input_stddev_pop_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# order by stddev_samp() on columns of table "input"
input input_stddev_samp_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# Streaming cursor of the table "input"
input input_stream_cursor_input {
  # Stream column input with initial value
  initial_value: input_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input input_stream_cursor_value_input {
  # The zero-based index of this input in the transaction.
  input_index: bigint

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: bigint

  # The 32-byte, double-sha256 hash of the network-encoded transaction from which this input is spent in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  outpoint_transaction_hash: bytea

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: bigint

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: bigint

  # The bytecode used to unlock a transaction output. To spend an output, unlocking bytecode must be included in a transaction input which – when evaluated in the authentication virtual machine with the locking bytecode – completes in valid state.
  unlocking_bytecode: bytea
}

# order by sum() on columns of table "input"
input input_sum_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# order by var_pop() on columns of table "input"
input input_var_pop_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# order by var_samp() on columns of table "input"
input input_var_samp_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# order by variance() on columns of table "input"
input input_variance_order_by {
  # The zero-based index of this input in the transaction.
  input_index: order_by

  # The zero-based index of the output being spent by this input. (An outpoint is a reference/pointer to a specific output in a previous transaction.)
  outpoint_index: order_by

  # The uint32 "sequence number" for this input, a complex bitfield which can encode several input properties: sequence age support – whether or not the input can use OP_CHECKSEQUENCEVERIFY; sequence age – the minimum number of blocks or length of time claimed to have passed since this input's source transaction was mined (up to approximately 1 year); locktime support – whether or not the input can use OP_CHECKLOCKTIMEVERIFY.
  sequence_number: order_by

  # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
  transaction_internal_id: order_by
}

# mutation root
type mutation_root {
  # Send an encoded transaction to the requested node for broadcast to the network.
  send_transaction(request: SendTransactionRequest!): SendTransactionResult!
}

# A trusted node which has been connected to this Chaingraph instance.
type node {
  # An array relationship
  accepted_blocks(
    # distinct select on columns
    distinct_on: [node_block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_block_order_by!]

    # filter the rows returned
    where: node_block_bool_exp
  ): [node_block!]!

  # The UTC timestamp at which this node was first connected to Chaingraph.
  first_connected_at: timestamp!

  # A unique, int32 identifier for this node assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: Int!

  # The UTC timestamp at which this node began its most recent connection to Chaingraph.
  latest_connection_began_at: timestamp!

  # The name configured as a stable identifier for this particular trusted node.
  name: String!

  # The protocol version reported by this node during the most recent connection handshake.
  protocol_version: Int!

  # The total number of unconfirmed transactions in the mempool of this node.
  unconfirmed_transaction_count: bigint

  # An array relationship
  unconfirmed_transactions(
    # distinct select on columns
    distinct_on: [node_transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_transaction_order_by!]

    # filter the rows returned
    where: node_transaction_bool_exp
  ): [node_transaction!]!

  # The user agent reported by this node during the most recent connection handshake.
  user_agent: String!
}

# A many-to-many relationship between nodes and blocks.
type node_block {
  # The UTC timestamp at which the referenced block was accepted by the referenced node. Set to NULL if the true acceptance time is unknown (the block was accepted by this node before Chaingraph began monitoring). In the event of a blockchain reorganization, the record is deleted from node_block and saved to node_block_history.
  accepted_at: timestamp

  # An object relationship
  block: block!

  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: bigint!

  # An object relationship
  node: node!

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: Int!
}

# order by aggregate values of table "node_block"
input node_block_aggregate_order_by {
  avg: node_block_avg_order_by
  count: order_by
  max: node_block_max_order_by
  min: node_block_min_order_by
  stddev: node_block_stddev_order_by
  stddev_pop: node_block_stddev_pop_order_by
  stddev_samp: node_block_stddev_samp_order_by
  sum: node_block_sum_order_by
  var_pop: node_block_var_pop_order_by
  var_samp: node_block_var_samp_order_by
  variance: node_block_variance_order_by
}

# order by avg() on columns of table "node_block"
input node_block_avg_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# Boolean expression to filter rows from the table "node_block". All fields are combined with a logical 'AND'.
input node_block_bool_exp {
  _and: [node_block_bool_exp!]
  _not: node_block_bool_exp
  _or: [node_block_bool_exp!]
  accepted_at: timestamp_comparison_exp
  block: block_bool_exp
  block_internal_id: bigint_comparison_exp
  node: node_bool_exp
  node_internal_id: Int_comparison_exp
}

# An archive of deleted node_blocks.
type node_block_history {
  # The UTC timestamp at which the referenced block was accepted by the referenced node in the deleted node_block. Set to NULL if the true acceptance time was unknown (the block was accepted by this node before Chaingraph began monitoring).
  accepted_at: timestamp

  # An object relationship
  block: block!

  # The internal_id (assigned by Chaingraph) of the block referenced by the deleted node_block.
  block_internal_id: bigint!

  # The internal_id (assigned by Chaingraph) of this node_block_history record.
  internal_id: bigint!

  # An object relationship
  node: node!

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_block.
  node_internal_id: Int!

  # The UTC timestamp at which the referenced block was removed by the referenced node.
  removed_at: timestamp!
}

# Boolean expression to filter rows from the table "node_block_history". All fields are combined with a logical 'AND'.
input node_block_history_bool_exp {
  _and: [node_block_history_bool_exp!]
  _not: node_block_history_bool_exp
  _or: [node_block_history_bool_exp!]
  accepted_at: timestamp_comparison_exp
  block: block_bool_exp
  block_internal_id: bigint_comparison_exp
  internal_id: bigint_comparison_exp
  node: node_bool_exp
  node_internal_id: Int_comparison_exp
  removed_at: timestamp_comparison_exp
}

# Ordering options when selecting data from "node_block_history".
input node_block_history_order_by {
  accepted_at: order_by
  block: block_order_by
  block_internal_id: order_by
  internal_id: order_by
  node: node_order_by
  node_internal_id: order_by
  removed_at: order_by
}

# select columns of table "node_block_history"
enum node_block_history_select_column {
  # column name
  accepted_at

  # column name
  block_internal_id

  # column name
  internal_id

  # column name
  node_internal_id

  # column name
  removed_at
}

# Streaming cursor of the table "node_block_history"
input node_block_history_stream_cursor_input {
  # Stream column input with initial value
  initial_value: node_block_history_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input node_block_history_stream_cursor_value_input {
  # The UTC timestamp at which the referenced block was accepted by the referenced node in the deleted node_block. Set to NULL if the true acceptance time was unknown (the block was accepted by this node before Chaingraph began monitoring).
  accepted_at: timestamp

  # The internal_id (assigned by Chaingraph) of the block referenced by the deleted node_block.
  block_internal_id: bigint

  # The internal_id (assigned by Chaingraph) of this node_block_history record.
  internal_id: bigint

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_block.
  node_internal_id: Int

  # The UTC timestamp at which the referenced block was removed by the referenced node.
  removed_at: timestamp
}

# order by max() on columns of table "node_block"
input node_block_max_order_by {
  # The UTC timestamp at which the referenced block was accepted by the referenced node. Set to NULL if the true acceptance time is unknown (the block was accepted by this node before Chaingraph began monitoring). In the event of a blockchain reorganization, the record is deleted from node_block and saved to node_block_history.
  accepted_at: order_by

  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# order by min() on columns of table "node_block"
input node_block_min_order_by {
  # The UTC timestamp at which the referenced block was accepted by the referenced node. Set to NULL if the true acceptance time is unknown (the block was accepted by this node before Chaingraph began monitoring). In the event of a blockchain reorganization, the record is deleted from node_block and saved to node_block_history.
  accepted_at: order_by

  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# Ordering options when selecting data from "node_block".
input node_block_order_by {
  accepted_at: order_by
  block: block_order_by
  block_internal_id: order_by
  node: node_order_by
  node_internal_id: order_by
}

# select columns of table "node_block"
enum node_block_select_column {
  # column name
  accepted_at

  # column name
  block_internal_id

  # column name
  node_internal_id
}

# order by stddev() on columns of table "node_block"
input node_block_stddev_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# order by stddev_pop() on columns of table "node_block"
input node_block_stddev_pop_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# order by stddev_samp() on columns of table "node_block"
input node_block_stddev_samp_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# Streaming cursor of the table "node_block"
input node_block_stream_cursor_input {
  # Stream column input with initial value
  initial_value: node_block_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input node_block_stream_cursor_value_input {
  # The UTC timestamp at which the referenced block was accepted by the referenced node. Set to NULL if the true acceptance time is unknown (the block was accepted by this node before Chaingraph began monitoring). In the event of a blockchain reorganization, the record is deleted from node_block and saved to node_block_history.
  accepted_at: timestamp

  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: bigint

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: Int
}

# order by sum() on columns of table "node_block"
input node_block_sum_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# order by var_pop() on columns of table "node_block"
input node_block_var_pop_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# order by var_samp() on columns of table "node_block"
input node_block_var_samp_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# order by variance() on columns of table "node_block"
input node_block_variance_order_by {
  # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
  block_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
  node_internal_id: order_by
}

# Boolean expression to filter rows from the table "node". All fields are combined with a logical 'AND'.
input node_bool_exp {
  _and: [node_bool_exp!]
  _not: node_bool_exp
  _or: [node_bool_exp!]
  accepted_blocks: node_block_bool_exp
  first_connected_at: timestamp_comparison_exp
  internal_id: Int_comparison_exp
  latest_connection_began_at: timestamp_comparison_exp
  name: String_comparison_exp
  protocol_version: Int_comparison_exp
  unconfirmed_transaction_count: bigint_comparison_exp
  unconfirmed_transactions: node_transaction_bool_exp
  user_agent: String_comparison_exp
}

# Ordering options when selecting data from "node".
input node_order_by {
  accepted_blocks_aggregate: node_block_aggregate_order_by
  first_connected_at: order_by
  internal_id: order_by
  latest_connection_began_at: order_by
  name: order_by
  protocol_version: order_by
  unconfirmed_transaction_count: order_by
  unconfirmed_transactions_aggregate: node_transaction_aggregate_order_by
  user_agent: order_by
}

# select columns of table "node"
enum node_select_column {
  # column name
  first_connected_at

  # column name
  internal_id

  # column name
  latest_connection_began_at

  # column name
  name

  # column name
  protocol_version

  # column name
  user_agent
}

# Streaming cursor of the table "node"
input node_stream_cursor_input {
  # Stream column input with initial value
  initial_value: node_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input node_stream_cursor_value_input {
  # The UTC timestamp at which this node was first connected to Chaingraph.
  first_connected_at: timestamp

  # A unique, int32 identifier for this node assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: Int

  # The UTC timestamp at which this node began its most recent connection to Chaingraph.
  latest_connection_began_at: timestamp

  # The name configured as a stable identifier for this particular trusted node.
  name: String

  # The protocol version reported by this node during the most recent connection handshake.
  protocol_version: Int

  # The user agent reported by this node during the most recent connection handshake.
  user_agent: String
}

# A many-to-many relationship between nodes and unconfirmed transactions, A.K.A. "mempool". Transactions which are first heard in a block are never recorded as node_transactions, but skip directly to being record by a pair of node_block and block_transaction relationships.
type node_transaction {
  # An object relationship
  node: node!

  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: Int!

  # An object relationship
  transaction: transaction!

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: bigint!

  # The UTC timestamp at which the referenced transaction was validated by the referenced node.
  validated_at: timestamp
}

# order by aggregate values of table "node_transaction"
input node_transaction_aggregate_order_by {
  avg: node_transaction_avg_order_by
  count: order_by
  max: node_transaction_max_order_by
  min: node_transaction_min_order_by
  stddev: node_transaction_stddev_order_by
  stddev_pop: node_transaction_stddev_pop_order_by
  stddev_samp: node_transaction_stddev_samp_order_by
  sum: node_transaction_sum_order_by
  var_pop: node_transaction_var_pop_order_by
  var_samp: node_transaction_var_samp_order_by
  variance: node_transaction_variance_order_by
}

# order by avg() on columns of table "node_transaction"
input node_transaction_avg_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by
}

# Boolean expression to filter rows from the table "node_transaction". All fields are combined with a logical 'AND'.
input node_transaction_bool_exp {
  _and: [node_transaction_bool_exp!]
  _not: node_transaction_bool_exp
  _or: [node_transaction_bool_exp!]
  node: node_bool_exp
  node_internal_id: Int_comparison_exp
  transaction: transaction_bool_exp
  transaction_internal_id: bigint_comparison_exp
  validated_at: timestamp_comparison_exp
}

# An archive of deleted node_transactions.
type node_transaction_history {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: bigint!

  # An object relationship
  node: node!

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: Int!

  # The UTC timestamp at which the referenced transaction was marked as replaced (A.K.A. double-spent) by the referenced node.
  replaced_at: timestamp

  # An object relationship
  transaction: transaction!

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: bigint!

  # The UTC timestamp at which the referenced transaction was validated by the referenced node in the deleted node_transaction.
  validated_at: timestamp
}

# order by aggregate values of table "node_transaction_history"
input node_transaction_history_aggregate_order_by {
  avg: node_transaction_history_avg_order_by
  count: order_by
  max: node_transaction_history_max_order_by
  min: node_transaction_history_min_order_by
  stddev: node_transaction_history_stddev_order_by
  stddev_pop: node_transaction_history_stddev_pop_order_by
  stddev_samp: node_transaction_history_stddev_samp_order_by
  sum: node_transaction_history_sum_order_by
  var_pop: node_transaction_history_var_pop_order_by
  var_samp: node_transaction_history_var_samp_order_by
  variance: node_transaction_history_variance_order_by
}

# order by avg() on columns of table "node_transaction_history"
input node_transaction_history_avg_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by
}

# Boolean expression to filter rows from the table "node_transaction_history". All fields are combined with a logical 'AND'.
input node_transaction_history_bool_exp {
  _and: [node_transaction_history_bool_exp!]
  _not: node_transaction_history_bool_exp
  _or: [node_transaction_history_bool_exp!]
  internal_id: bigint_comparison_exp
  node: node_bool_exp
  node_internal_id: Int_comparison_exp
  replaced_at: timestamp_comparison_exp
  transaction: transaction_bool_exp
  transaction_internal_id: bigint_comparison_exp
  validated_at: timestamp_comparison_exp
}

# order by max() on columns of table "node_transaction_history"
input node_transaction_history_max_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The UTC timestamp at which the referenced transaction was marked as replaced (A.K.A. double-spent) by the referenced node.
  replaced_at: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by

  # The UTC timestamp at which the referenced transaction was validated by the referenced node in the deleted node_transaction.
  validated_at: order_by
}

# order by min() on columns of table "node_transaction_history"
input node_transaction_history_min_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The UTC timestamp at which the referenced transaction was marked as replaced (A.K.A. double-spent) by the referenced node.
  replaced_at: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by

  # The UTC timestamp at which the referenced transaction was validated by the referenced node in the deleted node_transaction.
  validated_at: order_by
}

# Ordering options when selecting data from "node_transaction_history".
input node_transaction_history_order_by {
  internal_id: order_by
  node: node_order_by
  node_internal_id: order_by
  replaced_at: order_by
  transaction: transaction_order_by
  transaction_internal_id: order_by
  validated_at: order_by
}

# select columns of table "node_transaction_history"
enum node_transaction_history_select_column {
  # column name
  internal_id

  # column name
  node_internal_id

  # column name
  replaced_at

  # column name
  transaction_internal_id

  # column name
  validated_at
}

# order by stddev() on columns of table "node_transaction_history"
input node_transaction_history_stddev_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by
}

# order by stddev_pop() on columns of table "node_transaction_history"
input node_transaction_history_stddev_pop_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by
}

# order by stddev_samp() on columns of table "node_transaction_history"
input node_transaction_history_stddev_samp_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by
}

# Streaming cursor of the table "node_transaction_history"
input node_transaction_history_stream_cursor_input {
  # Stream column input with initial value
  initial_value: node_transaction_history_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input node_transaction_history_stream_cursor_value_input {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: bigint

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: Int

  # The UTC timestamp at which the referenced transaction was marked as replaced (A.K.A. double-spent) by the referenced node.
  replaced_at: timestamp

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: bigint

  # The UTC timestamp at which the referenced transaction was validated by the referenced node in the deleted node_transaction.
  validated_at: timestamp
}

# order by sum() on columns of table "node_transaction_history"
input node_transaction_history_sum_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by
}

# order by var_pop() on columns of table "node_transaction_history"
input node_transaction_history_var_pop_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by
}

# order by var_samp() on columns of table "node_transaction_history"
input node_transaction_history_var_samp_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by
}

# order by variance() on columns of table "node_transaction_history"
input node_transaction_history_variance_order_by {
  # The internal_id (assigned by Chaingraph) of this node_transaction_history record.
  internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the node referenced by the deleted node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by the deleted node_transaction.
  transaction_internal_id: order_by
}

# order by max() on columns of table "node_transaction"
input node_transaction_max_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by

  # The UTC timestamp at which the referenced transaction was validated by the referenced node.
  validated_at: order_by
}

# order by min() on columns of table "node_transaction"
input node_transaction_min_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by

  # The UTC timestamp at which the referenced transaction was validated by the referenced node.
  validated_at: order_by
}

# Ordering options when selecting data from "node_transaction".
input node_transaction_order_by {
  node: node_order_by
  node_internal_id: order_by
  transaction: transaction_order_by
  transaction_internal_id: order_by
  validated_at: order_by
}

# select columns of table "node_transaction"
enum node_transaction_select_column {
  # column name
  node_internal_id

  # column name
  transaction_internal_id

  # column name
  validated_at
}

# order by stddev() on columns of table "node_transaction"
input node_transaction_stddev_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by
}

# order by stddev_pop() on columns of table "node_transaction"
input node_transaction_stddev_pop_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by
}

# order by stddev_samp() on columns of table "node_transaction"
input node_transaction_stddev_samp_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by
}

# Streaming cursor of the table "node_transaction"
input node_transaction_stream_cursor_input {
  # Stream column input with initial value
  initial_value: node_transaction_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input node_transaction_stream_cursor_value_input {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: Int

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: bigint

  # The UTC timestamp at which the referenced transaction was validated by the referenced node.
  validated_at: timestamp
}

# order by sum() on columns of table "node_transaction"
input node_transaction_sum_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by
}

# order by var_pop() on columns of table "node_transaction"
input node_transaction_var_pop_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by
}

# order by var_samp() on columns of table "node_transaction"
input node_transaction_var_samp_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by
}

# order by variance() on columns of table "node_transaction"
input node_transaction_variance_order_by {
  # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
  node_internal_id: order_by

  # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
  transaction_internal_id: order_by
}

# column ordering options
enum order_by {
  # in ascending order, nulls last
  asc

  # in ascending order, nulls first
  asc_nulls_first

  # in ascending order, nulls last
  asc_nulls_last

  # in descending order, nulls first
  desc

  # in descending order, nulls first
  desc_nulls_first

  # in descending order, nulls last
  desc_nulls_last
}

# A transaction output.
type output {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: bigint

  # The bytecode used to encumber this transaction output. To spend the output, unlocking bytecode must be included in a transaction input which – when evaluated before this locking bytecode – completes in a valid state.
  locking_bytecode: bytea!

  # Extract the first byte of each instruction for the locking bytecode of an output. The resulting pattern excludes the contents of pushed values such that similar bytecode sequences produce the same pattern.
  locking_bytecode_pattern: String

  # The capability of the non-fungible token (NFT) held in this output: "none", "mutable", or "minting". This field is null if no NFT is present.
  nonfungible_token_capability: enum_nonfungible_token_capability

  # The commitment contents of the non-fungible token (NFT) held in this output (0 to 40 bytes). This field is null if no NFT is present.
  nonfungible_token_commitment: bytea

  # The zero-based index of this output in the transaction.
  output_index: bigint!

  # An array relationship
  spent_by(
    # distinct select on columns
    distinct_on: [input_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [input_order_by!]

    # filter the rows returned
    where: input_bool_exp
  ): [input!]!

  # The 32-byte token category to which the token(s) in this output belong. This field is null if no tokens are present.
  token_category: bytea

  # An object relationship
  transaction: transaction!

  # The 32-byte, double-sha256 hash of the network-encoded transaction containing this output in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  transaction_hash: bytea!

  # The value of this output in satoshis.
  value_satoshis: bigint!
}

# order by aggregate values of table "output"
input output_aggregate_order_by {
  avg: output_avg_order_by
  count: order_by
  max: output_max_order_by
  min: output_min_order_by
  stddev: output_stddev_order_by
  stddev_pop: output_stddev_pop_order_by
  stddev_samp: output_stddev_samp_order_by
  sum: output_sum_order_by
  var_pop: output_var_pop_order_by
  var_samp: output_var_samp_order_by
  variance: output_variance_order_by
}

# order by avg() on columns of table "output"
input output_avg_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# Boolean expression to filter rows from the table "output". All fields are combined with a logical 'AND'.
input output_bool_exp {
  _and: [output_bool_exp!]
  _not: output_bool_exp
  _or: [output_bool_exp!]
  fungible_token_amount: bigint_comparison_exp
  locking_bytecode: bytea_comparison_exp
  locking_bytecode_pattern: String_comparison_exp
  nonfungible_token_capability: enum_nonfungible_token_capability_comparison_exp
  nonfungible_token_commitment: bytea_comparison_exp
  output_index: bigint_comparison_exp
  spent_by: input_bool_exp
  token_category: bytea_comparison_exp
  transaction: transaction_bool_exp
  transaction_hash: bytea_comparison_exp
  value_satoshis: bigint_comparison_exp
}

# order by max() on columns of table "output"
input output_max_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The capability of the non-fungible token (NFT) held in this output: "none", "mutable", or "minting". This field is null if no NFT is present.
  nonfungible_token_capability: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# order by min() on columns of table "output"
input output_min_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The capability of the non-fungible token (NFT) held in this output: "none", "mutable", or "minting". This field is null if no NFT is present.
  nonfungible_token_capability: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# Ordering options when selecting data from "output".
input output_order_by {
  fungible_token_amount: order_by
  locking_bytecode: order_by
  locking_bytecode_pattern: order_by
  nonfungible_token_capability: order_by
  nonfungible_token_commitment: order_by
  output_index: order_by
  spent_by_aggregate: input_aggregate_order_by
  token_category: order_by
  transaction: transaction_order_by
  transaction_hash: order_by
  value_satoshis: order_by
}

# select columns of table "output"
enum output_select_column {
  # column name
  fungible_token_amount

  # column name
  locking_bytecode

  # column name
  nonfungible_token_capability

  # column name
  nonfungible_token_commitment

  # column name
  output_index

  # column name
  token_category

  # column name
  transaction_hash

  # column name
  value_satoshis
}

# order by stddev() on columns of table "output"
input output_stddev_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# order by stddev_pop() on columns of table "output"
input output_stddev_pop_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# order by stddev_samp() on columns of table "output"
input output_stddev_samp_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# Streaming cursor of the table "output"
input output_stream_cursor_input {
  # Stream column input with initial value
  initial_value: output_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input output_stream_cursor_value_input {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: bigint

  # The bytecode used to encumber this transaction output. To spend the output, unlocking bytecode must be included in a transaction input which – when evaluated before this locking bytecode – completes in a valid state.
  locking_bytecode: bytea

  # The capability of the non-fungible token (NFT) held in this output: "none", "mutable", or "minting". This field is null if no NFT is present.
  nonfungible_token_capability: enum_nonfungible_token_capability

  # The commitment contents of the non-fungible token (NFT) held in this output (0 to 40 bytes). This field is null if no NFT is present.
  nonfungible_token_commitment: bytea

  # The zero-based index of this output in the transaction.
  output_index: bigint

  # The 32-byte token category to which the token(s) in this output belong. This field is null if no tokens are present.
  token_category: bytea

  # The 32-byte, double-sha256 hash of the network-encoded transaction containing this output in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  transaction_hash: bytea

  # The value of this output in satoshis.
  value_satoshis: bigint
}

# order by sum() on columns of table "output"
input output_sum_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# order by var_pop() on columns of table "output"
input output_var_pop_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# order by var_samp() on columns of table "output"
input output_var_samp_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

# order by variance() on columns of table "output"
input output_variance_order_by {
  # The number of fungible tokens held in this output (an integer between 1 and 9223372036854775807). This field is null if 0 fungible tokens are present.
  fungible_token_amount: order_by

  # The zero-based index of this output in the transaction.
  output_index: order_by

  # The value of this output in satoshis.
  value_satoshis: order_by
}

type query_root {
  # fetch data from the table: "authchain_migrations_view"
  authchain_migrations_view(
    # distinct select on columns
    distinct_on: [authchain_migrations_view_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [authchain_migrations_view_order_by!]

    # filter the rows returned
    where: authchain_migrations_view_bool_exp
  ): [authchain_migrations_view!]!

  # fetch data from the table: "authchain_view"
  authchain_view(
    # distinct select on columns
    distinct_on: [authchain_view_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [authchain_view_order_by!]

    # filter the rows returned
    where: authchain_view_bool_exp
  ): [authchain_view!]!

  # fetch data from the table: "block"
  block(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): [block!]!

  # fetch data from the table: "block" using primary key columns
  block_by_pk(
    # A unique, int64 identifier for this block assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
    internal_id: bigint!
  ): block

  # fetch data from the table: "block_transaction"
  block_transaction(
    # distinct select on columns
    distinct_on: [block_transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_transaction_order_by!]

    # filter the rows returned
    where: block_transaction_bool_exp
  ): [block_transaction!]!

  # fetch data from the table: "block_transaction" using primary key columns
  block_transaction_by_pk(
    # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
    block_internal_id: bigint!

    # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
    transaction_internal_id: bigint!
  ): block_transaction

  # fetch data from the table: "input"
  input(
    # distinct select on columns
    distinct_on: [input_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [input_order_by!]

    # filter the rows returned
    where: input_bool_exp
  ): [input!]!

  # fetch data from the table: "input" using primary key columns
  input_by_pk(
    # The zero-based index of this input in the transaction.
    input_index: bigint!

    # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
    transaction_internal_id: bigint!
  ): input

  # fetch data from the table: "node"
  node(
    # distinct select on columns
    distinct_on: [node_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_order_by!]

    # filter the rows returned
    where: node_bool_exp
  ): [node!]!

  # fetch data from the table: "node_block"
  node_block(
    # distinct select on columns
    distinct_on: [node_block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_block_order_by!]

    # filter the rows returned
    where: node_block_bool_exp
  ): [node_block!]!

  # fetch data from the table: "node_block" using primary key columns
  node_block_by_pk(
    # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
    block_internal_id: bigint!

    # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
    node_internal_id: Int!
  ): node_block

  # fetch data from the table: "node_block_history"
  node_block_history(
    # distinct select on columns
    distinct_on: [node_block_history_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_block_history_order_by!]

    # filter the rows returned
    where: node_block_history_bool_exp
  ): [node_block_history!]!

  # fetch data from the table: "node_block_history" using primary key columns
  node_block_history_by_pk(
    # The internal_id (assigned by Chaingraph) of this node_block_history record.
    internal_id: bigint!
  ): node_block_history

  # fetch data from the table: "node" using primary key columns
  node_by_pk(
    # A unique, int32 identifier for this node assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
    internal_id: Int!
  ): node

  # fetch data from the table: "node_transaction"
  node_transaction(
    # distinct select on columns
    distinct_on: [node_transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_transaction_order_by!]

    # filter the rows returned
    where: node_transaction_bool_exp
  ): [node_transaction!]!

  # fetch data from the table: "node_transaction" using primary key columns
  node_transaction_by_pk(
    # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
    node_internal_id: Int!

    # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
    transaction_internal_id: bigint!
  ): node_transaction

  # fetch data from the table: "node_transaction_history"
  node_transaction_history(
    # distinct select on columns
    distinct_on: [node_transaction_history_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_transaction_history_order_by!]

    # filter the rows returned
    where: node_transaction_history_bool_exp
  ): [node_transaction_history!]!

  # fetch data from the table: "output"
  output(
    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]!

  # fetch data from the table: "output" using primary key columns
  output_by_pk(
    # The zero-based index of this output in the transaction.
    output_index: bigint!

    # The 32-byte, double-sha256 hash of the network-encoded transaction containing this output in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
    transaction_hash: bytea!
  ): output

  # execute function "search_output" which returns "output"
  search_output(
    # input parameters for function "search_output"
    args: search_output_args!

    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]!

  # execute function "search_output_prefix" which returns "output"
  search_output_prefix(
    # input parameters for function "search_output_prefix"
    args: search_output_prefix_args!

    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]!

  # fetch data from the table: "transaction"
  transaction(
    # distinct select on columns
    distinct_on: [transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [transaction_order_by!]

    # filter the rows returned
    where: transaction_bool_exp
  ): [transaction!]!

  # fetch data from the table: "transaction" using primary key columns
  transaction_by_pk(
    # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
    internal_id: bigint!
  ): transaction
}

input search_output_args {
  locking_bytecode_hex: _text
}

input search_output_prefix_args {
  locking_bytecode_prefix_hex: String
}

type subscription_root {
  # fetch data from the table: "authchain_migrations_view"
  authchain_migrations_view(
    # distinct select on columns
    distinct_on: [authchain_migrations_view_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [authchain_migrations_view_order_by!]

    # filter the rows returned
    where: authchain_migrations_view_bool_exp
  ): [authchain_migrations_view!]!

  # fetch data from the table in a streaming manner: "authchain_migrations_view"
  authchain_migrations_view_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [authchain_migrations_view_stream_cursor_input]!

    # filter the rows returned
    where: authchain_migrations_view_bool_exp
  ): [authchain_migrations_view!]!

  # fetch data from the table: "authchain_view"
  authchain_view(
    # distinct select on columns
    distinct_on: [authchain_view_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [authchain_view_order_by!]

    # filter the rows returned
    where: authchain_view_bool_exp
  ): [authchain_view!]!

  # fetch data from the table in a streaming manner: "authchain_view"
  authchain_view_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [authchain_view_stream_cursor_input]!

    # filter the rows returned
    where: authchain_view_bool_exp
  ): [authchain_view!]!

  # fetch data from the table: "block"
  block(
    # distinct select on columns
    distinct_on: [block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_order_by!]

    # filter the rows returned
    where: block_bool_exp
  ): [block!]!

  # fetch data from the table: "block" using primary key columns
  block_by_pk(
    # A unique, int64 identifier for this block assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
    internal_id: bigint!
  ): block

  # fetch data from the table in a streaming manner: "block"
  block_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [block_stream_cursor_input]!

    # filter the rows returned
    where: block_bool_exp
  ): [block!]!

  # fetch data from the table: "block_transaction"
  block_transaction(
    # distinct select on columns
    distinct_on: [block_transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_transaction_order_by!]

    # filter the rows returned
    where: block_transaction_bool_exp
  ): [block_transaction!]!

  # fetch data from the table: "block_transaction" using primary key columns
  block_transaction_by_pk(
    # The internal_id (assigned by Chaingraph) of the block referenced by this block_transaction.
    block_internal_id: bigint!

    # The internal_id (assigned by Chaingraph) of the transaction referenced by this block_transaction.
    transaction_internal_id: bigint!
  ): block_transaction

  # fetch data from the table in a streaming manner: "block_transaction"
  block_transaction_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [block_transaction_stream_cursor_input]!

    # filter the rows returned
    where: block_transaction_bool_exp
  ): [block_transaction!]!

  # fetch data from the table: "input"
  input(
    # distinct select on columns
    distinct_on: [input_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [input_order_by!]

    # filter the rows returned
    where: input_bool_exp
  ): [input!]!

  # fetch data from the table: "input" using primary key columns
  input_by_pk(
    # The zero-based index of this input in the transaction.
    input_index: bigint!

    # The internal_id (assigned by Chaingraph) of the transaction which includes this input.
    transaction_internal_id: bigint!
  ): input

  # fetch data from the table in a streaming manner: "input"
  input_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [input_stream_cursor_input]!

    # filter the rows returned
    where: input_bool_exp
  ): [input!]!

  # fetch data from the table: "node"
  node(
    # distinct select on columns
    distinct_on: [node_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_order_by!]

    # filter the rows returned
    where: node_bool_exp
  ): [node!]!

  # fetch data from the table: "node_block"
  node_block(
    # distinct select on columns
    distinct_on: [node_block_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_block_order_by!]

    # filter the rows returned
    where: node_block_bool_exp
  ): [node_block!]!

  # fetch data from the table: "node_block" using primary key columns
  node_block_by_pk(
    # The internal_id (assigned by Chaingraph) of the block referenced by this node_block.
    block_internal_id: bigint!

    # The internal_id (assigned by Chaingraph) of the node referenced by this node_block.
    node_internal_id: Int!
  ): node_block

  # fetch data from the table: "node_block_history"
  node_block_history(
    # distinct select on columns
    distinct_on: [node_block_history_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_block_history_order_by!]

    # filter the rows returned
    where: node_block_history_bool_exp
  ): [node_block_history!]!

  # fetch data from the table: "node_block_history" using primary key columns
  node_block_history_by_pk(
    # The internal_id (assigned by Chaingraph) of this node_block_history record.
    internal_id: bigint!
  ): node_block_history

  # fetch data from the table in a streaming manner: "node_block_history"
  node_block_history_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [node_block_history_stream_cursor_input]!

    # filter the rows returned
    where: node_block_history_bool_exp
  ): [node_block_history!]!

  # fetch data from the table in a streaming manner: "node_block"
  node_block_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [node_block_stream_cursor_input]!

    # filter the rows returned
    where: node_block_bool_exp
  ): [node_block!]!

  # fetch data from the table: "node" using primary key columns
  node_by_pk(
    # A unique, int32 identifier for this node assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
    internal_id: Int!
  ): node

  # fetch data from the table in a streaming manner: "node"
  node_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [node_stream_cursor_input]!

    # filter the rows returned
    where: node_bool_exp
  ): [node!]!

  # fetch data from the table: "node_transaction"
  node_transaction(
    # distinct select on columns
    distinct_on: [node_transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_transaction_order_by!]

    # filter the rows returned
    where: node_transaction_bool_exp
  ): [node_transaction!]!

  # fetch data from the table: "node_transaction" using primary key columns
  node_transaction_by_pk(
    # The internal_id (assigned by Chaingraph) of the node referenced by this node_transaction.
    node_internal_id: Int!

    # The internal_id (assigned by Chaingraph) of the transaction referenced by this node_transaction.
    transaction_internal_id: bigint!
  ): node_transaction

  # fetch data from the table: "node_transaction_history"
  node_transaction_history(
    # distinct select on columns
    distinct_on: [node_transaction_history_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_transaction_history_order_by!]

    # filter the rows returned
    where: node_transaction_history_bool_exp
  ): [node_transaction_history!]!

  # fetch data from the table in a streaming manner: "node_transaction_history"
  node_transaction_history_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [node_transaction_history_stream_cursor_input]!

    # filter the rows returned
    where: node_transaction_history_bool_exp
  ): [node_transaction_history!]!

  # fetch data from the table in a streaming manner: "node_transaction"
  node_transaction_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [node_transaction_stream_cursor_input]!

    # filter the rows returned
    where: node_transaction_bool_exp
  ): [node_transaction!]!

  # fetch data from the table: "output"
  output(
    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]!

  # fetch data from the table: "output" using primary key columns
  output_by_pk(
    # The zero-based index of this output in the transaction.
    output_index: bigint!

    # The 32-byte, double-sha256 hash of the network-encoded transaction containing this output in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
    transaction_hash: bytea!
  ): output

  # fetch data from the table in a streaming manner: "output"
  output_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [output_stream_cursor_input]!

    # filter the rows returned
    where: output_bool_exp
  ): [output!]!

  # execute function "search_output" which returns "output"
  search_output(
    # input parameters for function "search_output"
    args: search_output_args!

    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]!

  # execute function "search_output_prefix" which returns "output"
  search_output_prefix(
    # input parameters for function "search_output_prefix"
    args: search_output_prefix_args!

    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]!

  # fetch data from the table: "transaction"
  transaction(
    # distinct select on columns
    distinct_on: [transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [transaction_order_by!]

    # filter the rows returned
    where: transaction_bool_exp
  ): [transaction!]!

  # fetch data from the table: "transaction" using primary key columns
  transaction_by_pk(
    # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
    internal_id: bigint!
  ): transaction

  # fetch data from the table in a streaming manner: "transaction"
  transaction_stream(
    # maximum number of rows returned in a single batch
    batch_size: Int!

    # cursor to stream the results returned by the query
    cursor: [transaction_stream_cursor_input]!

    # filter the rows returned
    where: transaction_bool_exp
  ): [transaction!]!
}

scalar timestamp

# Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

# A transaction.
type transaction {
  # An array relationship
  authchains(
    # distinct select on columns
    distinct_on: [authchain_view_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [authchain_view_order_by!]

    # filter the rows returned
    where: authchain_view_bool_exp
  ): [authchain_view!]!

  # An array relationship
  block_inclusions(
    # distinct select on columns
    distinct_on: [block_transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [block_transaction_order_by!]

    # filter the rows returned
    where: block_transaction_bool_exp
  ): [block_transaction!]!

  # Return all of this transaction's "data carrier" outputs: outputs in which value_satoshis is 0 or locking_bytecode begins with OP_RETURN.
  data_carrier_outputs(
    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]

  # Encode a transaction using the standard P2P network format, returning the result as a hex-encoded string.
  encoded_hex: String

  # The fee in satoshis paid by this transaction.
  fee_satoshis: bigint

  # The 32-byte, double-sha256 hash of this transaction (encoded using the standard P2P network format) in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  hash: bytea!

  # Return a transaction's identity output (0th output). Making this a computed field simplifies Hasura queries by returning the identity output as a single object rather than a filtered array of one output.
  identity_output(
    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]

  # The total number of inputs in this transaction.
  input_count: bigint

  # An array relationship
  input_outpoint_transactions(
    # distinct select on columns
    distinct_on: [input_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [input_order_by!]

    # filter the rows returned
    where: input_bool_exp
  ): [input!]!

  # The total value in satoshis of all outputs spent by inputs in this transaction.
  input_value_satoshis: bigint

  # An array relationship
  inputs(
    # distinct select on columns
    distinct_on: [input_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [input_order_by!]

    # filter the rows returned
    where: input_bool_exp
  ): [input!]!

  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: bigint!

  # A boolean value indicating whether this transaction is a coinbase transaction. A coinbase transaction must be the 0th transaction in a block, it must have one input which spends from the empty outpoint_transaction_hash (0x0000...) and – after BIP34 – includes the block's height in its unlocking_bytecode (A.K.A. "coinbase" field), and it may spend the sum of the block's transaction fees and block reward to its output(s).
  is_coinbase: Boolean!

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: bigint!

  # An array relationship
  node_validation_timeline(
    # distinct select on columns
    distinct_on: [node_transaction_history_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_transaction_history_order_by!]

    # filter the rows returned
    where: node_transaction_history_bool_exp
  ): [node_transaction_history!]!

  # An array relationship
  node_validations(
    # distinct select on columns
    distinct_on: [node_transaction_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [node_transaction_order_by!]

    # filter the rows returned
    where: node_transaction_bool_exp
  ): [node_transaction!]!

  # The total number of outputs in this transaction.
  output_count: bigint

  # The total value in satoshis of all outputs created by this transaction.
  output_value_satoshis: bigint

  # An array relationship
  outputs(
    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]!

  # Return a transaction's signing output (1th output) or NULL if it does not exist. Making this a computed field simplifies Hasura queries by returning the signing output as a single object rather than a filtered array of one output.
  signing_output(
    # distinct select on columns
    distinct_on: [output_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [output_order_by!]

    # filter the rows returned
    where: output_bool_exp
  ): [output!]

  # The network-encoded size of this transaction in bytes.
  size_bytes: bigint!

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: bigint!
}

# order by aggregate values of table "transaction"
input transaction_aggregate_order_by {
  avg: transaction_avg_order_by
  count: order_by
  max: transaction_max_order_by
  min: transaction_min_order_by
  stddev: transaction_stddev_order_by
  stddev_pop: transaction_stddev_pop_order_by
  stddev_samp: transaction_stddev_samp_order_by
  sum: transaction_sum_order_by
  var_pop: transaction_var_pop_order_by
  var_samp: transaction_var_samp_order_by
  variance: transaction_variance_order_by
}

# order by avg() on columns of table "transaction"
input transaction_avg_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# Boolean expression to filter rows from the table "transaction". All fields are combined with a logical 'AND'.
input transaction_bool_exp {
  _and: [transaction_bool_exp!]
  _not: transaction_bool_exp
  _or: [transaction_bool_exp!]
  authchains: authchain_view_bool_exp
  block_inclusions: block_transaction_bool_exp
  data_carrier_outputs: output_bool_exp
  encoded_hex: String_comparison_exp
  fee_satoshis: bigint_comparison_exp
  hash: bytea_comparison_exp
  identity_output: output_bool_exp
  input_count: bigint_comparison_exp
  input_outpoint_transactions: input_bool_exp
  input_value_satoshis: bigint_comparison_exp
  inputs: input_bool_exp
  internal_id: bigint_comparison_exp
  is_coinbase: Boolean_comparison_exp
  locktime: bigint_comparison_exp
  node_validation_timeline: node_transaction_history_bool_exp
  node_validations: node_transaction_bool_exp
  output_count: bigint_comparison_exp
  output_value_satoshis: bigint_comparison_exp
  outputs: output_bool_exp
  signing_output: output_bool_exp
  size_bytes: bigint_comparison_exp
  version: bigint_comparison_exp
}

# order by max() on columns of table "transaction"
input transaction_max_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# order by min() on columns of table "transaction"
input transaction_min_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# Ordering options when selecting data from "transaction".
input transaction_order_by {
  authchains_aggregate: authchain_view_aggregate_order_by
  block_inclusions_aggregate: block_transaction_aggregate_order_by
  data_carrier_outputs_aggregate: output_aggregate_order_by
  encoded_hex: order_by
  fee_satoshis: order_by
  hash: order_by
  identity_output_aggregate: output_aggregate_order_by
  input_count: order_by
  input_outpoint_transactions_aggregate: input_aggregate_order_by
  input_value_satoshis: order_by
  inputs_aggregate: input_aggregate_order_by
  internal_id: order_by
  is_coinbase: order_by
  locktime: order_by
  node_validation_timeline_aggregate: node_transaction_history_aggregate_order_by
  node_validations_aggregate: node_transaction_aggregate_order_by
  output_count: order_by
  output_value_satoshis: order_by
  outputs_aggregate: output_aggregate_order_by
  signing_output_aggregate: output_aggregate_order_by
  size_bytes: order_by
  version: order_by
}

# select columns of table "transaction"
enum transaction_select_column {
  # column name
  hash

  # column name
  internal_id

  # column name
  is_coinbase

  # column name
  locktime

  # column name
  size_bytes

  # column name
  version
}

# order by stddev() on columns of table "transaction"
input transaction_stddev_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# order by stddev_pop() on columns of table "transaction"
input transaction_stddev_pop_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# order by stddev_samp() on columns of table "transaction"
input transaction_stddev_samp_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# Streaming cursor of the table "transaction"
input transaction_stream_cursor_input {
  # Stream column input with initial value
  initial_value: transaction_stream_cursor_value_input!

  # cursor ordering
  ordering: cursor_ordering
}

# Initial value of the column from where the streaming should start
input transaction_stream_cursor_value_input {
  # The 32-byte, double-sha256 hash of this transaction (encoded using the standard P2P network format) in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).
  hash: bytea

  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: bigint

  # A boolean value indicating whether this transaction is a coinbase transaction. A coinbase transaction must be the 0th transaction in a block, it must have one input which spends from the empty outpoint_transaction_hash (0x0000...) and – after BIP34 – includes the block's height in its unlocking_bytecode (A.K.A. "coinbase" field), and it may spend the sum of the block's transaction fees and block reward to its output(s).
  is_coinbase: Boolean

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: bigint

  # The network-encoded size of this transaction in bytes.
  size_bytes: bigint

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: bigint
}

# order by sum() on columns of table "transaction"
input transaction_sum_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# order by var_pop() on columns of table "transaction"
input transaction_var_pop_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# order by var_samp() on columns of table "transaction"
input transaction_var_samp_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}

# order by variance() on columns of table "transaction"
input transaction_variance_order_by {
  # A unique, int64 identifier for this transaction assigned by Chaingraph. This value is not guaranteed to be consistent between Chaingraph instances.
  internal_id: order_by

  # The uint32 locktime at which this transaction is considered valid. Locktime can be provided as either a timestamp or a block height: values less than 500,000,000 are understood to be a block height (the current block number in the chain, beginning from block 0); values greater than or equal to 500,000,000 are understood to be a UNIX timestamp.
  locktime: order_by

  # The network-encoded size of this transaction in bytes.
  size_bytes: order_by

  # The version of this transaction. In the v1 and v2 transaction formats, a 4-byte field typically represented as an int32. (Verson 2 transactions are defined in BIP68.)
  version: order_by
}
